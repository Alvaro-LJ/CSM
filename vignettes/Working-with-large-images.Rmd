---
title: "Working with large images"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Working-with-large-images}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style>
p {
  text-align: justify;
}
</style>


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, results='hide'}
library(CSM)
```

## Index

- [Introduction](#introduction)
- [Test dataset info](#test-datasets)
- [Check computing resources](#check-computing-resources-available)
- [Chopping large images](#chopping-large-images)
- [Cell segmentation using tiles](#cell-segmentation-using-tiled-images)
- [Pixel thresholding using tiles](#pixel-thresholding-of-tiled-images-and-re-assembled-images)

***

## Introduction
Working with large images can be painful in R. Whole slide images can exceedingly large (up to tens of gigabytes). This
can easily saturate RAM memory. Indeed many popular image handling R packages (like EBImage or magick) have image size
limits that can be easily exceeded by whole slide images. 

CSM has inbuilt pipelines to deal with this situation. CSM implements functions to chop large images into manageable smaller crops. 
After image processing (either cell segmentation, cell phenotype labeling or image pixel thresholding), cell or image 
pixel information can be re-assembled to match the original whole slide coordinates.


## Test datasets

The test datasets consists of two small 500x500 pixels breast carcinoma images. They have been stained with a multiplexed
immunofluorescence protocol for the following markers: "DAPI", "PDL1", "GZMB", "PD1", "CK-EPCAM", "CD8a", "FOXP3". 
The original images can be found at: https://immunoatlas.org/.

This is a trivial test dataset, as it contains very small images that could be easily handled by CSM. However, the principles
described in this example apply to larger whole-slide images.

```{r Images, eval = FALSE, results='hide'}
#Can only run in an interactive setting
#Generate a temporary directory to place the input images
Input_Dir <- tempfile(pattern = "tempdir1_Input")
dir.create(Input_Dir, recursive = TRUE)

#Save images in Input directory
purrr::map(1:2,
function(Image){
   EBImage::writeImage(CSM_MiniMultiTiff_test[[Image]],
   file.path(Input_Dir, names(CSM_MiniMultiTiff_test)[Image]))
})
```


## Check computing resources available
It is always a good idea to first check the CPU and RAM available.

```{r check, eval = TRUE}
Describe_my_computing_unit()
```

## Chopping large images
`Image_tile_deconstruction_function()` divides all the images in a directory into tiles. Accepted file extension include TIFF and OME.TIFF.
User can select the tile size (in pixels),the image channels to keep and the tile overlap. The smaller the tile size the easier it will 
be to work with the resulting chopped images, at the cost of an increased total tile number. If cell segmentation is going to be performed, 
tile overlap may be applied to account for segmentation artifacts due to edge proximity. Cell redundancy will be corrected in subsequent steps.
If RGB images need to be chopped, all RGB channels will be kept. The image chopping process is powered by the RBioFormats bioconductor R package. 

```{r chop, eval = FALSE}
#Can only run in an interactive setting
Input_Dir <- tempfile(pattern = "tempdir1_Input")
Output_Dir <- tempfile(pattern = "tempdir2_Output")
dir.create(Input_Dir, recursive = TRUE)
dir.create(Output_Dir, recursive = TRUE)

#Save images in Input directory
purrr::map(1:2,
function(Image){
   EBImage::writeImage(CSM_MiniMultiTiff_test[[Image]],
   file.path(Input_Dir, names(CSM_MiniMultiTiff_test)[Image]))
})

#Perform tiling---------------------------------------------------
Image_tile_deconstruction_function(
   Directory = Input_Dir,
   Output_directory = Output_Dir,
   Ordered_Channels = c("DAPI", "PDL1", "GZMB", "PD1", "CK-EPCAM", "CD8a", "FOXP3"),
   Channels_to_keep = c("DAPI", "PDL1", "GZMB", "PD1", "CK-EPCAM", "CD8a", "FOXP3"),
   RGB_Color_images = FALSE,
   Tile_pixel_size = 250,
   Tile_Overlap = 50,
   N_cores = 1
)

#Check that files have been created-----------------------------------------
list.files(Output_Dir)
```

## Cell segmentation using tiled images
Cell segmentation and feature extraction proceeds as usual.
```{r Segment, eval = FALSE}
#Can only run in an interactive setting
Cell_DATA_tiles <- 
  Cell_segmentator_quantificator(
    Directory = Output_Dir,
    Parameter_list = CSM_SegmentParams_test,
    N_cores = 1,
    quantiles_to_calculate = 0.5
)
```

After cell segmentation has been performed, the dataset needs to be formatted using the `Data_arrange_function()`. 
Then, original cell coordinates can be obtained by running `Tile_to_image_cell_arrange_function()`. If tile overlap is detected, 
redundant cells (sharing spatial coordinates) will be removed automatically. In addition, 
if there is tile overlap, cells close to a shared tile edge can be removed according to
user preferences (with the 'Dist_to_edge' argument). The function works based on the information contained in the file name.
Manipulating the name can result in unexpected results. __PLEASE AVOID FILE NAME MODIFICATIONS!__
```{r Reassign_coordinates, eval = FALSE}
#Can only run in an interactive setting
#Arrange data
Cell_DATA_tiles <- 
  Data_arrange_function(
    DATA = Cell_DATA_tiles,
    X = 'm.cx',
    Y = "m.cy",
    Subject_Names = "imageID",
    Markers_to_keep = c("CK-EPCAM_AVERAGE", "CD8a_AVERAGE", "GZMB_AVERAGE")
)

#Return to original image X Y coordinates
Cell_DATA_WholeImage <-
  Tile_to_image_cell_arrange_function(
    DATA = Cell_DATA_tiles,
    Dist_to_edge = 20
)

#Check that results are OK
Cell_DATA_WholeImage %>% 
  dplyr::filter(Subject_Names == "ABCM22001_B09_MiniCrop.tiff") %>%
  ggplot2::ggplot(ggplot2::aes(x = X, y = Y)) + ggplot2::geom_point()

```

## Pixel thresholding of tiled images and re-assembled images
Single channels can be pixel-thresholded using image chunks. Afterwards thresholded image chunks can be used to re-assemble a 
thresholded whole image using the `Image_from_tile_rebuilder()` function. Since image chunks will be used in the thresholding process,
LOCAL thresholding using automatic algorithms can be extremely problematic (high risk of setting thresholds according to local artifacts).
Therefore, GLOBAL thresholding is highly recommended.

If images are being chopped to be thresholded, overlap between images is not supported. Although no error will be thrown by the 
related functions, the re-build process of overlapping tiles will result in aberrant re-assembled images.
```{r Tile_threshold, eval = FALSE}
#Can only run in an interactive setting
Input_Dir <- tempfile(pattern = "tempdir1_Input")
Output_Dir_tiles <- tempfile(pattern = "tempdir2_Output")
Output_Dir_tiles_thresholded <- tempfile(pattern = "tempdir3_Output")
Output_Dir_reconstruction <- tempfile(pattern = "tempdir4_Output")
dir.create(Input_Dir, recursive = TRUE)
dir.create(Output_Dir_tiles, recursive = TRUE)
dir.create(Output_Dir_tiles_thresholded, recursive = TRUE)
dir.create(Output_Dir_reconstruction, recursive = TRUE)

#Save images in Input directory
purrr::map(1:2,
function(Image){
   EBImage::writeImage(CSM_MiniMultiTiff_test[[Image]],
   file.path(Input_Dir, names(CSM_MiniMultiTiff_test)[Image]))
})

#Divide images into tiles------------------------------------------------------
Image_tile_deconstruction_function(
   Directory = Input_Dir,
   Output_directory = Output_Dir_tiles,
   Ordered_Channels = c("DAPI", "PDL1", "GZMB", "PD1", "CK-EPCAM", "CD8a", "FOXP3"),
   Channels_to_keep = c("DAPI", "PDL1", "GZMB", "PD1", "CK-EPCAM", "CD8a", "FOXP3"),
   RGB_Color_images = FALSE,
   Tile_pixel_size = 250,
   Tile_Overlap = 0,
   N_cores = 1
)

#Threshold the CK_EPCAM channel of tiles
Pixel_Threshold_calculator(
     N_cores = 1,
     Directory = Output_Dir_tiles,
     Ordered_Channels = c("DAPI", "PDL1", "GZMB", "PD1", "CK-EPCAM", "CD8a", "FOXP3"),
     Channels_to_keep = c("DAPI", "PDL1", "GZMB", "PD1", "CK-EPCAM", "CD8a", "FOXP3"),
     Target_channel = "CK-EPCAM",

     Save_processed_images = TRUE,
     Output_Directory = Output_Dir_tiles_thresholded,

     Local_thresholding = FALSE,
     Threshold_type = "Arbitrary",
     Threshold_value = 0.02,

     Threshold_type_tissueMask = "Absolute",
     Threshold_value_tissueMask = 0.001,
     Blurr_tissueMask = TRUE,
     Sigma_tissueMask = 0.5,
     Blurr_target = FALSE
)

#Rebuild images from tiles-----------------------
Image_from_tile_rebuilder(
   Directory = Output_Dir_tiles_thresholded,
   Output_directory = Output_Dir_reconstruction,
   RGB_Color_images = FALSE,
   N_cores = 1
)

#Check the files created-------------------------------------------------
list.files(Output_Dir_reconstruction)

#Remove directories---------------------------------------------------------
unlink(c(Input_Dir, Output_Dir_tiles, Output_Dir_tiles_thresholded, Output_Dir_reconstruction), recursive = TRUE)
```

```{r Session_info, eval = TRUE, fig.align='center', out.width='100%', fig.width = 10, fig.height = 8}
sessionInfo()
```
