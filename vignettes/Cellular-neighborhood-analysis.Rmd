---
title: "Cellular neighborhood analysis"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Cellular-neighborhood-analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style>
p {
  text-align: justify;
}
</style>

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


```{r setup, results='hide'}
library(CSM)
```

## Index

- [Introduction](#introduction)
- [Test dataset info](#test-datasets)
- [Closest neighbor-based approach](#closest-neighbor-based-approach)
    - [Conventional closest neighbors](#conventional-closest-neighbors)
    - [UTAG](#utag)
    - [Quantification](#quantification)
- [Tiled-based approach](#tiled-based-approach)
- [Global interaction pattern (imcRtools)](#global-interaction-pattern-(imcRtools))
- [SPIAT-based](#spiat-based)

***

## Introduction
Neighborhood analysis can reveal complex cellular interaction patterns. These tools are able to identify recurrent
patterns of multi-cellular interaction. They are all based on the notion of spatial association which is defined according
to the first law of geography:

<p style="text-align: right;"><em>“Everything is related to everything else, but near things are more related than distant things.”</em></p>
<p style="text-align: right;">  — Waldo Tobler, 1970</p>

Although this definition is also relevant for cell-to-cell spatial interaction analysis, it is of paramount importance for 
neighborhood analysis. Neighborhood analysis requires defining when two cells can be considered neighbors, which implies
defining what "near" means. Different algorithms define neighbors in different manners, conditioning the final result.

CSM implements several approaches to identify neighborhoods:

* __[Closest neighbor-based approach](#closest-neighbor-based-approach):__ These approaches are based on calculating the
  neighbors for every cell. Afterwards this information is used to identify patterns.
    * __[Conventional closest neighbors](#conventional-closest-neighbors):__ For every cell it's closest neighbors are 
    calculated. The presence of different cell types is quantified among neighbors to build the closest neighbor matrix.
    Afterwards, recurrent patterns are identified in this matrix.
    * __[UTAG](#utag):__ Based on the original publication from the Elemento group
    (https://www.nature.com/articles/s41592-022-01657-2), CSM implements the Unsupervised 
    discovery of Tissue Architecture with Graphs algorithm with several modifications to increase flexibility.
    In essence, UTAG works by combining cell features, with the features of their close neighbors. This process is
    known as 'message passing'. Afterwards, the resulting combined features are clustered to identify recurrent patterns.
    UTAG is interesting because it can perform cell neighborhood analysis without requiring prior cell phenotype labels.
* __[Tiled-based approach](#tiled-based-approach):__ This approach requires the overlaying a tile grid over the tissue area.
  Cells within each tile are considered to belong to the same neighborhood. Recurrent cell type composition among neighborhoods
  are then identified by performing clustering. These recurrent patterns summarize neighborhood architectures within tissues.
  Tiled-based approaches are computationally efficient and very intuitive to understand. 
  However, they are subject to the 'Modifiable areal unit problem' that is discussed in the 'Calculating tissue heterogeneity' vignette 
  (please run `vignette("Calculating-tissue-heterogeneity")` for more information).
* __[Global interaction pattern (imcRtools)](#global-interaction-pattern-(imcRtools)):__ CSM ports imcRtools neighborhood discovery pipeline.
  This pipeline first computes graphs between cell types and computes interaction scores for every cell type pair. Each sample, has an
  interaction score for every cell type pair. Global interaction patterns are identified across samples, not cell types. These approach
  is a good choice to perform neighborhood analysis at the sample level in stead of the cell level.
  
## Test datasets
The test dataset includes cell feature matrix obtained from two 500x500 breast carcinoma images. 
They have been stained with a multiplexed immunofluorescence technique for the following markers: 
"DAPI", "PDL1", "GZMB", "PD1", "CK-EPCAM", "CD8a", "FOXP3". 
The original images can be found at: https://immunoatlas.org/.

For the current example we will use information from around 1K cells. The cells have been assigned a cell phenotype label
by feature positivity pattern.
In addition, the cell feature matrix without phenotype labels will be used for the UTAG example.

```{r data, eval = TRUE}
CSM_Phenotypecell_test
CSM_Arrangedcellfeaturedata_test
```

## [Closest neighbor-based approach](#closest-neighbor-based-approach)
The closest neighbor approach requires a definition of neighbors. Currently, CSM supports three ways of defining neighbors:

* __N closest cells:__ The neighbors of any cell in the sample are it's N closest cells, being N an integer number. As N increases,
  neighborhoods start reflecting broader interaction patterns. If N is kept small, only local interactions will be recorded. This approach
  has a main disadvantage. Since this neighbor definition is not spatially restricted, non-neighboring cells may be identified as neighbors.
  For example, the N closest cells to a single cell that is spatially isolated (like a cell stranded in the middle of stroma) will
  not reflect true spatial interactions. This approach calculates the N closest cells, irrespective of the actual distance between these and the cell of origin.
  An advantage of this approach is that the same number of neighbors is computed for all cells. This facilitates the interpretation of cell type percentages within
  neighbors.
* __Distance:__ The neighbors of a cell in the sample are those cells within a distance of D, being D a numeric value. As with N closest
  cells definition, as D value increases broader interaction patterns are captured. Since this definition is spatially restricted, it is not subject
  to the bias described in the N closest cells. However, distance alone does not reflect spatial interaction. The number of simultaneous cellular interactions
  any cell can experience is not infinite. In addition, the total neighbor count for every cell may vary according to cell density. This means that cell percentages
  may not be easily comparable between cells. However, since the distance analyzed is fixed, cell counts effectively reflect cell type densities within the neighborhood.
  This can be a biologically relevant metric.
* __N and D:__ It sounds reasonable to combine both definitions. The neighbors of any cell are restricted by the number N and by distance D. In practice this means that
  the neighbors of any cell are the N closest neighbors, given that all of these cells are within distance D from the cell of origin. Although this definition is very
  powerful, the interpretation of results can be cumbersome. The total amount of neighbors by cell and the maximum distance to the cell of origin will be variable.
  This makes percentages and densities less meaningful.
  
Once neighbors have been identified, closest neighbors approach identify recurrent pattern using clustering. This recurrent patterns are considered the neighborhoods.
Clustering options are similar to those described in the vinegette 'Cell-phenotype-labelling' (please run `vignette('Cell-phenotype-labelling')`, for more information).
Clustering parameters can also influence the final result. Users are encouraged to explore different approaches to reach a satisfactory result.

In practice, the choice of neighbor definition and the choice of parameters is arbitrary. Depending on the choice, different types of neighborhoods summarizing
various types of spatial patterns can be identified. There is no single way to identify neighborhoods.

### Conventional closest neighbors
This pipeline starts by computing the closest neighbor matrix. This matrix contains a summary of the neighbors from every cell included in the analysis.  
CSM function `Tailored_Closest_neighbor_calculator()` does this job. It requires a dataframe or tibble containing cell phenotype labels. The function allows
users to select which cells of origin will be visited, and what cells can be considered to be neighbors (target cells). 

In the followin example we will calculate neighbors, defined as any cell within 30 pixels from the COO. Cells labelled as 'OTHER' will not be visited by the
algorithm, but will be considered as neighbors.

```{r closest_neighbors, eval = TRUE, fig.align='center', out.width='100%', fig.width = 10, fig.height = 8}
Closest_neighbors <- 
  Tailored_Closest_neighbor_calculator(
    N_cores = 1,
    DATA = CSM_Phenotypecell_test,
    Strategy = "Distance",
    Include_COO_in_neighborhood = TRUE,
    Max_dist_allowed = 30,
    Cell_Of_Origin = c("TUMOR", "CD8_GZMBneg", "CD8_GZMBpos"),
    Target_Cell = c("TUMOR", "CD8_GZMBneg", "CD8_GZMBpos", "OTHER")
)

#Print the resulting list
Closest_neighbors
```
  
The function returns a list containing closest neighbors expressed as percentages and as absolute counts (reflecting density if calculated by distance).
In addition, it plots the correlation between cell types in the neighborhoods. This can be a proxy of interaction/repulsion patterns. For example from the
resulting correlation coefficients, it can be concluded that as TUMOR cells increase in the neighborhood, the presence of any other cell type decreases (repulsion pattern).
In contrast, GZMB negative and positive CD8 T cells are positively correlated, implying spatial clustering. The function also returns histograms reporting
the average, median and maximum distances of neighbors to the COO. The 0 distance reflects those cells without neighbors.

Once we have obtained the closest neighbor matrix we can cluster it to obtain neighborhoods. In this case we will use the 'Absolute_count' tibble to take into account
cell densities within the neighborhood. The function `Neighborhood_discovery_function()` allows filtering by distance (useful for defined by N). The example will be
kept simple and we will set the maximum number of neighborhoods identified to 3.

```{r Neighborhood_discovery, eval = FALSE, fig.align='center', out.width='100%', fig.width = 10, fig.height = 8}
#Can only run interactively
Neighborhoods_by_cell <- 
  Neighborhood_discovery_function(
   DATA = Closest_neighbors$Absolute_count,
   Allowed_max_Dist = 31,
   Allowed_avg_Dist = 31,
   Allowed_median_Dist = 31,

   Perform_Dimension_reduction = TRUE,
   Dimension_reduction = "UMAP",
   Dimension_reduction_prop = 1,
   Cluster_on_Reduced = FALSE,

   Strategy = "GMM",
   Quality_metric = "AIC",
   Max_N_neighborhoods_GMM = 3,
   Max_iterations_km = 10,
   Max_iterations_em = 10,
   GMM_Distance = "eucl_dist"
)

Neighborhoods_by_cell
```

The function will return graphs describing neighborhood cellular composition. Afterwards we can rename our neighborhoods using the
`DATA_neighborhoods_renamer()`. Afterwards we could proceed with other analyses.

```{r Neighborhood_renaming, eval = FALSE, fig.align='center', out.width='100%', fig.width = 10, fig.height = 8}
#Can only run interactively
DATA_Neighborhoods_names <-
 DATA_neighborhoods_renamer(
    DATA = Neighborhoods_by_cell$DATA,
    New_names = c("TUMOR_RICH", "IMMUNE_NICHE", "CD8_NEG_RICH")
)
```

### UTAG
As mentioned above, UTAG first performs message passing. This process allows neighboring cells to share feature information.
In CSM the UTAG algorithm has been tweaked to allow different neighboring cell definitions (see above). In addition,
the UTAG message passing function developed for CSM (`UTAG_message_passing()`) has 4 other interesting features:

* __COO to visit:__ If the user has some previous information regarding cells of interest, it can be used to ameliorate computational demands.
  COO_to_visit argument allows the user to select which cells will be visited by the algorithm and considered COO. It should be a logical vector where
  TRUE cells are visited and FALSE cells are ignored. However, ignored cells will also be taken into account as target cells.
* __Message strategy:__ There are two ways the feature information from neighbors can be combined:
    * __Averaging:__ Adds the features and divides them by the total amount of neighbors. Well suited to perform all types of weighting. Does not take into account the density of cells in the 
    neighborhood.
    * __Sum:__ Adds the cell features values alone. Is compatible with proximity weighting (see below). Takes into account the cell density in the neighborhood. It can increase the dinamic 
    range of features.
* __COO weight:__ Message passing can somehow dilute the feature information contained by COO. In cases where there are too many neighbors, message passing can
  erase almost completely the information provided by the original COO. This may or may not be an issue. Anyways, the function allows the user to provide a fixed
  weight for the COO during message passing. The weight will be the same for all COO visited by the algorithm.
* __Neighbor's weights:__ Should all the neighbors share their features equally? Imagine the following scenario: the COO has 10 closest neighbors, 5 within a 10 pixel
  distance and the others more than 50 pixels away. Should they all have the same weights during message passing? Alternatively think about this situation. One of the 
  features is only rarely expressed in the data or is shows very low expression values on average. However very few high expressing cells can be encountered from time to time.
  Should we boost the signal from these low expression markers so that it is not diluted during message passing?
  The function allows both correcting for proximity to COO and by low expression (disregarded_minority correction)
    * __Proximity correction:__ Every neighbor is at distance d from the COO. The sum of all distances d is D. Weight for every neighbor is calculated as the following:
$$
Weight = {\frac{1}{\frac{d}{D}}} 
$$
    * __Disregarded minority correction:__ First the -log10 of the average expression in the dataset is calculated for all features. The weight is calculated as the following:
$$
Weight = {\frac{-log10(\bar{x})}{\min(-log10(\bar{x}))}} 
$$

After deciding the parameters message passing can be performed. Here we will apply the same neighbor definition as for conventional closest neighbors. We
will take into account proximity to COO in message passing.

```{r Message_passing, eval = TRUE, fig.align='center', out.width='100%', fig.width = 10, fig.height = 8}
Message_passed_cells <- 
  UTAG_message_passing(
    DATA = CSM_Arrangedcellfeaturedata_test,

    Neighbor_strategy = "Distance",
    Message_strategy = "Averaging",
    Max_dist_allowed = 30,
    Weighting_Strategy = "Proximity",

    N_cores = 1
)

#we will check the difference between features before and after message passing
library(purrr)
library(ggplot2)
library(magrittr)
map(5:7, function(column_index){
  Before <- CSM_Arrangedcellfeaturedata_test[[column_index]]
  After <- Message_passed_cells[[column_index]]
  
  Absolute_min <- min(c(Before, After))
  Absolute_max <- max(c(Before, After))
  
  tibble::tibble(Before = Before,
                 After = After) %>%
    ggplot(aes(x = Before, y = After)) +
    geom_point() +
    scale_x_continuous("Before", limits = c(Absolute_min, Absolute_max)) +
    scale_y_continuous("After", limits = c(Absolute_min, Absolute_max)) +
    annotate("segment",x = Absolute_min, y = Absolute_min, xend = Absolute_max, yend = Absolute_max) +
    ggtitle(names(CSM_Arrangedcellfeaturedata_test)[column_index])
})
```

It can be observed that feature values change dramatically after message passing.

If we perform message passing by sum in stead, we would obtain always higher feature values.
```{r Message_passing_sum, eval = TRUE, fig.align='center', out.width='100%', fig.width = 10, fig.height = 8}
Message_passed_cells_sum <- 
  UTAG_message_passing(
    DATA = CSM_Arrangedcellfeaturedata_test,

    Neighbor_strategy = "Distance",
    Message_strategy = "Sum",
    Max_dist_allowed = 30,
    Weighting_Strategy = "Proximity",

    N_cores = 1
)

#we will check the difference between features before and after message passing
library(purrr)
library(ggplot2)
library(magrittr)
map(5:7, function(column_index){
  Before <- CSM_Arrangedcellfeaturedata_test[[column_index]]
  After <- Message_passed_cells_sum[[column_index]]
  
  Absolute_min <- min(c(Before, After))
  Absolute_max <- max(c(Before, After))
  
  tibble::tibble(Before = Before,
                 After = After) %>%
    ggplot(aes(x = Before, y = After)) +
    geom_point() +
    scale_x_continuous("Before", limits = c(Absolute_min, Absolute_max)) +
    scale_y_continuous("After", limits = c(Absolute_min, Absolute_max)) +
    annotate("segment",x = Absolute_min, y = Absolute_min, xend = Absolute_max, yend = Absolute_max) +
    ggtitle(names(CSM_Arrangedcellfeaturedata_test)[column_index])
})
```

Once the message passing process has been completed it is time to cluster the results to obtain neighborhoods. When analyzing clustering results
is important to take into account that this is no longer cell information, but rather information regarding neighborhoods. To find neighborhoods
CSM implements the function `UTAG_Neighborhood_identifier()`. It use is similar to the function `Clustering_Phenotyper()` seen in the Cell-phenotype-labelling 
vignette.

```{r UTAG, eval = FALSE, fig.align='center', out.width='100%', fig.width = 10, fig.height = 8}
#Can only run interactively
UTAG_Neighborhood_identifier(
   DATA = Message_passed_cells,
   Strategy = "Batch_K_means",
   Min_Neighbors = 3,

   Apply_Denoise = TRUE,
   Denoising = "Otsu",

   Perform_Dimension_reduction = TRUE,
   Dimension_reduction = "UMAP",
   Dimension_reduction_prop = 1,
   Cluster_on_Reduced = FALSE,

   Batch_size = 100,
   Max_N_neighborhoods_Batch = 5,
   N_initiations = 10,
   Max_iterations = 10
)
```

As for conventional closest neighbor neighborhood analysis, neighborhood names can be modified with `DATA_neighborhoods_renamer()`.

### Quantification
Before quantification, the user can check the concordance between neighborhood identification approaches using the `Concordance_calculator()` and
`Confusion_matrix_plotter()` described in the vignette "Cell phenotype labelling".

After performing neighborhood analysis, the next reasonable step is to quantify results. Every cell in the dataset has been assigned to a neighborhood.
The initial quantification step just quantifies the number of cells belonging to each neighborhood for every sample. In addition, neighborhood density
can also be quantified.

```{r Quantification_standard, eval = FALSE, fig.align='center', out.width='100%', fig.width = 10, fig.height = 8}
#Can only run interactively
Neighborhood_Quantifier(
    DATA = DATA_Neighborhoods_names,
    Calculate_Density = FALSE
)
```

This initial quantification step can reveal interesting patterns. However, it can be heavily influenced by cell density. If a neighborhood pattern is associated with
high cell density (for example a neighborhood consisting of heavily packed tumor cells), identifying a high proportion of cells belonging to this neighborhood may not
be informative. 

Therefore, another approach is to divide the tissue samples into tiles and analyze the amount of tiles where each neighborhood can be found. As described in the
vignette "Calculating tissue heterogeneity", the first step for any tile analysis is to divide the dataset into tiles

```{r Tiling, eval = FALSE, fig.align='center', out.width='100%', fig.width = 10, fig.height = 8}
#Can only run interactively
Tiled_images <- Image_tiling_processing_function(N_cores = 1, 
                                                 DATA = DATA_Neighborhoods_names, 
                                                 Tile_width = 100, 
                                                 Tile_height = 100, 
                                                 Variables_to_keep = "Neighborhood_assignment"
                                                 ) 
#print the first element
Tiled_Images[[1]]
```

After Tiling it can be interesting to quantify the number of neighborhoods present in each tile. The `Neighborhood_voting_function()` quantifies the number of cells belonging
to each neighborhood by tile. In addition, it returns the most represented neighborhood by tile. This information can be useful to have an idea if spatial clustering of neighborhoods.

```{r Tiling, eval = FALSE, fig.align='center', out.width='100%', fig.width = 10, fig.height = 8}
#Can only run interactively
DATA_Neighborhood_elections <- Neighborhood_voting_function(N_cores = 1, 
                                                            Tiled_Images = Tiled_images, 
                                                            Minimum_cell_no_per_tile = 1, 
                                                            Neighborhoods_included = c("TUMOR_RICH", "IMMUNE_NICHE", "CD8_NEG_RICH")
                                                            )
```

Finally results can be graph the results.
```{r Graph_tiles, eval = FALSE, fig.align='center', out.width='100%', fig.width = 10, fig.height = 8}
Tiled_neighborhoods_graphicator(DATA_elections = DATA_Neighborhood_elections, #Specify the object containing the data neighborhood elections
                                Image_name = "ABCM22001_B14_MiniCrop.tif", #Provide the name of the sample
                                Graph_only_winner_neighborhood = FALSE #Specify if only the winner neighborhood in each tile should be graphed
)
```
