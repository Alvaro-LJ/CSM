% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Tiled_Image_Clustering_function.R
\name{Tiled_Image_Clustering_function}
\alias{Tiled_Image_Clustering_function}
\title{Performs neighborhood identification based on tiled images}
\usage{
Tiled_Image_Clustering_function(
  Tiled_images = NULL,
  Minimum_cell_no_per_tile = NULL,
  Minimum_valid_tiles_per_image = NULL,
  Phenotypes_included = NULL,
  Cluster_Data = NULL,
  Perform_Dimension_reduction = NULL,
  Dimension_reduction = NULL,
  Dimension_reduction_prop = NULL,
  Cluster_on_Reduced = NULL,
  Strategy = NULL,
  Max_N_Clusters = NULL,
  Consensus_reps = NULL,
  Consensus_p_Items = NULL,
  Consensus_Cluster_Alg = NULL,
  Consensus_Distance = NULL,
  Consensus_Name = NULL,
  Max_SOM_Clusters = NULL,
  Graph_type = NULL,
  Graph_Method = NULL,
  Nearest_neighbors_for_graph = NULL,
  Graph_Resolution = NULL,
  Graph_Distance_method = NULL,
  N_steps = NULL,
  N_K_centroids = NULL,
  Max_N_Clusters_Meta = NULL,
  Consensus_reps_Meta = NULL,
  Consensus_p_Items_Meta = NULL,
  Consensus_Name_Meta = NULL,
  Batch_size = NULL,
  Max_N_Clusters_Batch = NULL,
  Percentage_centroid_initiation = NULL,
  N_initiations = NULL,
  Max_iterations = NULL,
  Quality_metric = NULL,
  Max_N_Clusters_GMM = NULL,
  Max_iterations_km = NULL,
  Max_iterations_em = NULL,
  GMM_Distance = NULL,
  Samples_CLARA = NULL,
  Sample_per_CLARA = NULL,
  Max_N_Clusters_CLARA = NULL,
  Distance_CLARA = NULL,
  N_cores = NULL
)
}
\arguments{
\item{Tiled_images}{A list containing tiled images obtained using \code{\link[=Image_tiling_processing_function]{Image_tiling_processing_function()}}.}

\item{Minimum_cell_no_per_tile}{An integer indicating the minimum number of cells that a tile must contain. Tiles below the limit will not be included in the analysis.}

\item{Minimum_valid_tiles_per_image}{An integer indicating the minimum number of valid tiles an image must contain. Images below the limits will not be included in the analysis.}

\item{Phenotypes_included}{A character vector indicating the cell phenotypes that will be included in the clustering process.}

\item{Cluster_Data}{Either 'Cell_Density' or 'Cell_Percentage'}

\item{Perform_Dimension_reduction}{Logical value. Should Dimension Reduction be performed (see details).}

\item{Dimension_reduction}{Dimension reduction method. One of the following: PCA, TSNE, UMAP.}

\item{Dimension_reduction_prop}{A numeric value between 0 and 1 to indicate the percentage of the cells to be used in dimension computation (applicable for TSNE and UMAP).}

\item{Cluster_on_Reduced}{A logical value indicating if clustering should be performed on new dimensions.}

\item{Strategy}{One of the following Consensus_Clustering, SOM, Graph_Based, K_Means_Meta_clustering, Batch_K_means, GMM or CLARA_clustering (see details).}

\item{Max_N_Clusters}{If Strategy is Consensus_Clustering: Number of maximum Clusters that can be identified.}

\item{Consensus_reps}{If Strategy is Consensus_Clustering: Number of iterations to converge.}

\item{Consensus_p_Items}{If Strategy is Consensus_Clustering: Percentage of cells that you desire to sample in each iteration.}

\item{Consensus_Cluster_Alg}{If Strategy is Consensus_Clustering: Clustering algorithm to be used (’hc’ hierarchical (hclust), ’pam’ for paritioning around medoids, ’km’ for k-means).}

\item{Consensus_Distance}{If Strategy is Consensus_Clustering: Distance metric to be used (pearson(1 - Pearson correlation), spearman(1 - Spearman correlation), euclidean, binary, maximum, canberra, minkowski.}

\item{Consensus_Name}{If Strategy is Consensus_Clustering: Name of the folder that is going to be created in order to place the resulting graphs.}

\item{Max_SOM_Clusters}{If Strategy is SOM: umber of maximum Clusters that can be identified.}

\item{Graph_type}{If strategy is Graph_Based: Choose the type of graph to be build: 'complete' (more accurate but computationally intensive), 'SNN' (nearest neighbor) or 'Dimension_SNN' (based on dimension reduction data).}

\item{Graph_Method}{If strategy is Graph_Based: One of Louvain, Leiden, Greedy, WalkTrap, Spinglass, Leading_Eigen or Edge_Betweenness.}

\item{Nearest_neighbors_for_graph}{If strategy is Graph_Based: The number of closest neighbors to calculate the graph for SNN graphs.}

\item{Graph_Resolution}{If strategy is Graph_Based: Used for Louvain and Leiden. 1 is default. The smaller the value, the larger the clusters will be.}

\item{Graph_Distance_method}{If strategy is Graph_Based: The distance metric used to build complete graphs (euclidean, maximum, manhattan, canberra, binary or minkowski).}

\item{N_steps}{If strategy is Graph_Based: Number of steps given in the WalkTrap algorithm.}

\item{N_K_centroids}{If strategy is K_Means_Meta_clustering: Number of centroids to perform K means.}

\item{Max_N_Clusters_Meta}{If strategy is K_Means_Meta_clustering: Number of maximum Clusters that can be identified.}

\item{Consensus_reps_Meta}{If strategy is K_Means_Meta_clustering: Number of iterations to converge.}

\item{Consensus_p_Items_Meta}{If strategy is K_Means_Meta_clustering: Percentage of cells that you desire to sample in each iteration.}

\item{Consensus_Name_Meta}{If strategy is K_Means_Meta_clustering: Name of the folder that is going to be created in order to place the resulting graphs.}

\item{Batch_size}{If strategy is Batch_K_means: Number of cells to be included in each random batch.}

\item{Max_N_Clusters_Batch}{If strategy is Batch_K_means: Number of maximum Clusters that can be identified.}

\item{N_initiations}{If strategy is Batch_K_means: Number of times the algorithm is going to be tried to find the best clustering result.}

\item{Max_iterations}{If strategy is Batch_K_means: Max number of iterations in each try.}

\item{Quality_metric}{If strategy is GMM:T he quality measure used to test the number of clusters ("AIC" or "BIC").}

\item{Max_N_Clusters_GMM}{If strategy is GMM: Number of maximum Clusters that can be identified.}

\item{Max_iterations_km}{If strategy is GMM: Number of max iterations in the K means clustering performed.}

\item{Max_iterations_em}{If strategy is GMM: Number of max iterations in the Expectation Maximization algorithm.}

\item{GMM_Distance}{If strategy is GMM: Distance metric used in the model ("eucl_dist" or "maha_dist").}

\item{Samples_CLARA}{If strategy is CLARA_clustering: Number of samples the CLARA algorithm is going to use to be calculated.}

\item{Sample_per_CLARA}{If strategy is CLARA_clustering: Percentage (from 0 to 1) of the total cells that are going to be allocated to each sample.}

\item{Max_N_Clusters_CLARA}{If strategy is CLARA_clustering: Number of maximum Clusters that can be identified.}

\item{Distance_CLARA}{If strategy is CLARA_clustering: Distance metric used in the model (euclidean, manhattan, chebyshev, canberra, braycurtis, pearson_correlation, simple_matching_coefficient, minkowski, hamming, jaccard_coefficient, Rao_coefficient, mahalanobis, cosine)}

\item{N_cores}{If strategy is CLARA_clustering: Number of cores to parallelize your computation}
}
\value{
Returns a list containing the tiles with their corresponding neighborhood assignment.
}
\description{
Identifies tiles with recurrent cell patterns. Images must have been previously tiled using \code{\link[=Image_tiling_processing_function]{Image_tiling_processing_function()}} function.
}
\details{
Dimension reduction can be performed using PCA (svd::propack.svd function), t-SNE (snifter::fitsne function) and UMAP (uwot::tumap function). For t-SNE and UMAP a model can be build using a subset of data and then predicting coordinates for all the cells. This can be more computationally efficient.

Consensus clustering is performed using the ConsensusClusterPlus::ConsensusClusterPlus function.

Self Organizing Maps clustering is performed using the FlowSOM::FlowSOM function.

For graph based clustering Nearest neighbors graphs are built using bluster::makeSNNGraph and clustered using functions included in the igraph package.

K_Means_Meta_clustering first summarizes cell feature matrix observations using K means algorithm and the performs Consensus Clustering. Afterwards results are generalized to all cells.

Batch K-means, Gaussian Mixture Models and Clustering Large Applications are all based on the ClusterR package.
}
\examples{
\dontrun{
#Tile images with cell phenotype information---------------------------------
Tiled_Images <-
 Image_tiling_processing_function(
   N_cores = 1,
   DATA = CSM_Phenotypecell_test,
   Tile_width = 125,
   Tile_height = 125,
   Variables_to_keep = "Phenotype"
)

#Cluster cell composition by tile to find neighborhoods---------------------
Tiled_Image_Clustering_function(
    Tiled_images = Tiled_Images,
    Minimum_cell_no_per_tile = 4,
    Minimum_valid_tiles_per_image = 4,
    Phenotypes_included = unique(CSM_Phenotypecell_test$Phenotype),

    Cluster_Data = "Cell_Density",

    Perform_Dimension_reduction = FALSE,
    Cluster_on_Reduced = FALSE,

   Strategy = "Consensus_Clustering",
   Max_N_Clusters = 5,
   Consensus_reps = 2,
   Consensus_p_Items = 1,
   Consensus_Cluster_Alg = "pam",
   Consensus_Distance = "euclidean",
   Consensus_Name = "Consensus_clustering_test"
)
}

}
\seealso{
\code{\link[=Image_tiling_processing_function]{Image_tiling_processing_function()}}, \code{\link[=Clustered_Tiled_Images_renamer]{Clustered_Tiled_Images_renamer()}}, \code{\link[=Clustered_Tiled_Images_analyzer]{Clustered_Tiled_Images_analyzer()}}, \code{\link[=Clustered_Tiled_Images_graphicator]{Clustered_Tiled_Images_graphicator()}}
}
