% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Neighborhood_discovery_function.R
\name{Neighborhood_discovery_function}
\alias{Neighborhood_discovery_function}
\title{Performs neighborhood identification}
\usage{
Neighborhood_discovery_function(
  DATA,
  Allowed_max_Dist,
  Allowed_avg_Dist,
  Allowed_median_Dist,
  Perform_Dimension_reduction = FALSE,
  Dimension_reduction = NULL,
  Dimension_reduction_prop = NULL,
  Cluster_on_Reduced = NULL,
  Strategy,
  Max_N_neighborhoods = NULL,
  Consensus_reps = NULL,
  Consensus_p_Items = NULL,
  Consensus_Cluster_Alg = NULL,
  Consensus_Distance = NULL,
  Consensus_Name = NULL,
  Max_SOM_neighborhoods = NULL,
  Graph_type = NULL,
  Graph_Method = NULL,
  Nearest_neighbors_for_graph = NULL,
  Graph_Resolution = NULL,
  Graph_Distance_method = NULL,
  N_steps = NULL,
  N_K_centroids = NULL,
  Max_N_neighborhoods_Meta = NULL,
  Consensus_reps_Meta = NULL,
  Consensus_p_Items_Meta = NULL,
  Consensus_Name_Meta = NULL,
  Batch_size = NULL,
  Max_N_neighborhoods_Batch = NULL,
  N_initiations = NULL,
  Max_iterations = NULL,
  Quality_metric = NULL,
  Max_N_neighborhoods_GMM = NULL,
  Max_iterations_km = NULL,
  Max_iterations_em = NULL,
  GMM_Distance = NULL,
  Samples_CLARA = NULL,
  Sample_per_CLARA = NULL,
  Max_N_neighborhoods_CLARA = NULL,
  Distance_CLARA = NULL,
  N_cores = NULL
)
}
\arguments{
\item{DATA}{A dataframe or tibble containing closest neighbor information calculated using \code{\link[=Tailored_Closest_neighbor_calculator]{Tailored_Closest_neighbor_calculator()}}.}

\item{Allowed_max_Dist}{A numeric value indicating the allowed max distance to neighbors. Cells above threshold will be removed from analysis.}

\item{Allowed_avg_Dist}{A numeric value indicating the allowed average distance to neighbors. Cells above threshold will be removed from analysis.}

\item{Allowed_median_Dist}{A numeric value indicating the allowed median distance to neighbors. Cells above threshold will be removed from analysis.}

\item{Perform_Dimension_reduction}{Logical value. Should Dimension Reduction be performed (see details).}

\item{Dimension_reduction}{Dimension reduction method. One of the following: PCA, TSNE, UMAP.}

\item{Dimension_reduction_prop}{A numeric value between 0 and 1 to indicate the percentage of the cells to be used in dimension computation (applicable for TSNE and UMAP).}

\item{Cluster_on_Reduced}{A logical value indicating if clustering should be performed on new dimensions.}

\item{Strategy}{The clustering strategy. One of the following Consensus_Clustering, SOM, Graph_Based, K_Means_Meta_clustering, Batch_K_means, GMM or CLARA_clustering (see details).}

\item{Max_N_neighborhoods}{If Strategy is Consensus_Clustering: Number of maximum neighborhoods that can be identified.}

\item{Consensus_reps}{If Strategy is Consensus_Clustering: Number of iterations to converge.}

\item{Consensus_p_Items}{If Strategy is Consensus_Clustering: Percentage of cells that you desire to sample in each iteration.}

\item{Consensus_Cluster_Alg}{If Strategy is Consensus_Clustering: Clustering algorithm to be used (’hc’ hierarchical (hclust), ’pam’ for paritioning around medoids, ’km’ for k-means).}

\item{Consensus_Distance}{If Strategy is Consensus_Clustering: Distance metric to be used (pearson(1 - Pearson correlation), spearman(1 - Spearman correlation), euclidean, binary, maximum, canberra, minkowski.}

\item{Consensus_Name}{If Strategy is Consensus_Clustering: Name of the folder that is going to be created in order to place the resulting graphs.}

\item{Max_SOM_neighborhoods}{If Strategy is SOM: umber of maximum neighborhoods that can be identified.}

\item{Graph_type}{If Strategy is Graph_Based: A character value indicating the type of graph to build. Either "Complete" or "SNN" (nearest neighbors).}

\item{Graph_Method}{If strategy is Graph_Based: One of Louvain, Leiden, Greedy, WalkTrap, Spinglass, Leading_Eigen or Edge_Betweenness.}

\item{Nearest_neighbors_for_graph}{If strategy is Graph_Based: The number of closest neighbors to calculate the graph.}

\item{Graph_Resolution}{If strategy is Graph_Based: Used for Louvain and Leiden. 1 is default. The smaller the value, the larger the clusters will be.}

\item{Graph_Distance_method}{If strategy is Graph_Based and Graph_type is complete, a character value indicating the distance method used to build the graph. One of the following: "euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski".}

\item{N_steps}{If strategy is Graph_Based: Number of steps given in the WalkTrap algorithm.}

\item{N_K_centroids}{If strategy is K_Means_Meta_clustering: Number of centroids to perform K means.}

\item{Max_N_neighborhoods_Meta}{If strategy is K_Means_Meta_clustering: Number of maximum neighborhoods that can be identified.}

\item{Consensus_reps_Meta}{If strategy is K_Means_Meta_clustering: Number of iterations to converge.}

\item{Consensus_p_Items_Meta}{If strategy is K_Means_Meta_clustering: Percentage of cells that you desire to sample in each iteration.}

\item{Consensus_Name_Meta}{If strategy is K_Means_Meta_clustering: Name of the folder that is going to be created in order to place the resulting graphs.}

\item{Batch_size}{If strategy is Batch_K_means: Number of cells to be included in each random batch.}

\item{Max_N_neighborhoods_Batch}{If strategy is Batch_K_means: Number of maximum neighborhoods that can be identified.}

\item{N_initiations}{If strategy is Batch_K_means: Number of times the algorithm is going to be tried to find the best clustering result.}

\item{Max_iterations}{If strategy is Batch_K_means: Max number of iterations in each try.}

\item{Quality_metric}{If strategy is GMM:T he quality measure used to test the number of clusters ("AIC" or "BIC").}

\item{Max_N_neighborhoods_GMM}{If strategy is GMM: Number of maximum neighborhoods that can be identified.}

\item{Max_iterations_km}{If strategy is GMM: Number of max iterations in the K means clustering performed.}

\item{Max_iterations_em}{If strategy is GMM: Number of max iterations in the Expectation Maximization algorithm.}

\item{GMM_Distance}{If strategy is GMM: Distance metric used in the model ("eucl_dist" or "maha_dist").}

\item{Samples_CLARA}{If strategy is CLARA_clustering: Number of samples the CLARA algorithm is going to use to be calculated.}

\item{Sample_per_CLARA}{If strategy is CLARA_clustering: Percentage (from 0 to 1) of the total cells that are going to be allocated to each sample.}

\item{Max_N_neighborhoods_CLARA}{If strategy is CLARA_clustering: Number of maximum neighborhoods that can be identified.}

\item{Distance_CLARA}{If strategy is CLARA_clustering: Distance metric used in the model (euclidean, manhattan, chebyshev, canberra, braycurtis, pearson_correlation, simple_matching_coefficient, minkowski, hamming, jaccard_coefficient, Rao_coefficient, mahalanobis, cosine)}

\item{N_cores}{If strategy is CLARA_clustering: Number of cores to parallelize your computation}
}
\value{
Returns a tibble with cell features and a column named 'Neighborhood_assignment' containing cell neighborhood.
If dimension reduction has been performed returns a list with the cell feature dataset as above and a tibble containing dimension reduction coordinates.
}
\description{
The function assigns every cell in a dataset to a neighborhood through a clustering process. Closest neighbor cell feature matrix calculated using \code{\link[=Tailored_Closest_neighbor_calculator]{Tailored_Closest_neighbor_calculator()}} must be used.
}
\details{
Dimension reduction can be performed using PCA (svd::propack.svd function), t-SNE (snifter::fitsne function) and UMAP (uwot::tumap function). For t-SNE and UMAP a model can be build using a subset of data and then predicting coordinates for all the cells. This can be more computationally efficient.

Consensus clustering is performed using the ConsensusClusterPlus::ConsensusClusterPlus function.

Self Organizing Maps clustering is performed using the FlowSOM::FlowSOM function.

For graph based clustering Nearest neighbors graphs (SNNG) are built using bluster::makeSNNGraph and clustered using functions included in the igraph package.

K_Means_Meta_clustering first summarizes cell feature matrix observations using K means algorithm and the performs Consensus Clustering. Afterwards results are generalized to all cells.

Batch K-means, Gaussian Mixture Models and Clustering Large Applications are all based on the ClusterR package.
}
\examples{
\dontrun{
#Calculate the closest neighbor matrix----------------------------------------
DATA_Closest_Neighbors <-
Tailored_Closest_neighbor_calculator(
   N_cores = 1,
   DATA = CSM_Phenotypecell_test,
   Strategy = "Distance",
   Include_COO_in_neighborhood = TRUE,
   Max_dist_allowed = 50,
   Cell_Of_Origin = c("TUMOR", "CD8_GZMBneg", "CD8_GZMBpos"),
   Target_Cell = c("TUMOR", "CD8_GZMBneg", "CD8_GZMBpos", "OTHER")
)

#Cluster the result to obtain neighborhoods-----------------------------------
Neighborhood_discovery_function(
   DATA = DATA_Closest_Neighbors$Absolute_count,
   Allowed_max_Dist = 51,
   Allowed_avg_Dist = 51,
   Allowed_median_Dist = 51,

   Perform_Dimension_reduction = TRUE,
   Dimension_reduction = "UMAP",
   Dimension_reduction_prop = 1,
   Cluster_on_Reduced = TRUE,

   Strategy = "GMM",
   Quality_metric = "AIC",
   Max_N_neighborhoods_GMM = 5,
   Max_iterations_km = 10,
   Max_iterations_em = 10,
   GMM_Distance = "eucl_dist"
)
}

}
\seealso{
\code{\link[=Tailored_Closest_neighbor_calculator]{Tailored_Closest_neighbor_calculator()}}, \code{\link[=DATA_neighborhoods_renamer]{DATA_neighborhoods_renamer()}}, \code{\link[=Neighborhood_Quantifier]{Neighborhood_Quantifier()}}, \code{\link[=Neighborhood_voting_function]{Neighborhood_voting_function()}}, \code{\link[=Tiled_neighborhoods_graphicator]{Tiled_neighborhoods_graphicator()}}
}
