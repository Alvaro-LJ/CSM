% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/UTAG_Neighborhood_identifier.R
\name{UTAG_Neighborhood_identifier}
\alias{UTAG_Neighborhood_identifier}
\title{Performs neighborhood identification based on message-passed cells features}
\usage{
UTAG_Neighborhood_identifier(
  DATA = NULL,
  Strategy = NULL,
  Min_Neighbors = NULL,
  Apply_Denoise = NULL,
  Denoising = NULL,
  Percentile = NULL,
  N_Standard_Deviations = NULL,
  Selected_threshold = NULL,
  Min_cell_no = NULL,
  Distance_radius = NULL,
  Perform_Dimension_reduction = NULL,
  Dimension_reduction = NULL,
  Dimension_reduction_prop = NULL,
  Cluster_on_Reduced = NULL,
  Max_N_neighborhoods = NULL,
  Consensus_reps = NULL,
  Consensus_p_Items = NULL,
  Consensus_Cluster_Alg = NULL,
  Consensus_Distance = NULL,
  Consensus_Name = NULL,
  Max_SOM_neighborhoods = NULL,
  Nearest_neighbors_for_graph = NULL,
  Graph_Method = NULL,
  Graph_Resolution = NULL,
  N_steps = NULL,
  N_K_centroids = NULL,
  Max_N_neighborhoods_Meta = NULL,
  Consensus_reps_Meta = NULL,
  Consensus_p_Items_Meta = NULL,
  Consensus_Name_Meta = NULL,
  Batch_size = NULL,
  Max_N_neighborhoods_Batch = NULL,
  N_initiations = NULL,
  Max_iterations = NULL,
  Quality_metric = NULL,
  Max_N_neighborhoods_GMM = NULL,
  Max_iterations_km = NULL,
  Max_iterations_em = NULL,
  GMM_Distance = NULL,
  Samples_CLARA = NULL,
  Sample_per_CLARA = NULL,
  Max_N_neighborhoods_CLARA = NULL,
  Distance_CLARA = NULL,
  N_cores = NULL
)
}
\arguments{
\item{DATA}{A dataframe or tibble containing message-passed cell feature data obtained using \code{\link[=UTAG_message_passing]{UTAG_message_passing()}} function.}

\item{Strategy}{One of the following Consensus_Clustering, SOM, Graph_Based, K_Means_Meta_clustering, Batch_K_means, GMM or CLARA_clustering (see details).}

\item{Min_Neighbors}{A numeric value indicating the minimum amount of neighbors. Cells with a number of neighbors below the threshold will be removed from analysis.}

\item{Apply_Denoise}{A logical value. Specify if a denoising filtering is required before clustering (see details).}

\item{Denoising}{Denoising strategy. One of the following: Quantile, Standard_Deviation, Threshold, Otsu or DimRed_DBscan.}

\item{Percentile}{A numeric value indicating the percentile for quantile threshold. Cells below percentile for all features will be considered to be noise.}

\item{N_Standard_Deviations}{A numeric value indicating the number of standard deviations from mean for Standard_Deviation method. Cells below SD for all features will be considered to be noise.}

\item{Selected_threshold}{A numeric value indicating the threshold to be used for the Threshold method. Cells below the threshold for all features will be considered to be noise.}

\item{Min_cell_no}{An integer value for the DBscan method. Minimum cell number in distance to consider a cell to be clustered.}

\item{Distance_radius}{A numeric value for the DBscan method. Distance to be sampled.}

\item{Perform_Dimension_reduction}{Logical value. Should Dimension Reduction be performed (see details).}

\item{Dimension_reduction}{Dimension reduction method. One of the following: PCA, TSNE, UMAP.}

\item{Dimension_reduction_prop}{A numeric value between 0 and 1 to indicate the percentage of the cells to be used in dimension computation (applicable for TSNE and UMAP).}

\item{Cluster_on_Reduced}{A logical value indicating if clustering should be performed on new dimensions.}

\item{Max_N_neighborhoods}{If Strategy is Consensus_Clustering: Number of maximum neighborhoods that can be identified.}

\item{Consensus_reps}{If Strategy is Consensus_Clustering: Number of iterations to converge.}

\item{Consensus_p_Items}{If Strategy is Consensus_Clustering: Percentage of cells that you desire to sample in each iteration.}

\item{Consensus_Cluster_Alg}{If Strategy is Consensus_Clustering: Clustering algorithm to be used: hc (hierarchical clustering), pam (paritioning around medoids), km (for k-means).}

\item{Consensus_Distance}{If Strategy is Consensus_Clustering: Distance metric to be used (pearson(1 - Pearson correlation), spearman(1 - Spearman correlation), euclidean, binary, maximum, canberra, minkowski.}

\item{Consensus_Name}{If Strategy is Consensus_Clustering: Name of the folder that is going to be created in order to place the resulting graphs.}

\item{Max_SOM_neighborhoods}{If Strategy is SOM: umber of maximum neighborhoods that can be identified.}

\item{Nearest_neighbors_for_graph}{If strategy is Graph_Based: The number of closest neighbors to calculate the graph.}

\item{Graph_Method}{If strategy is Graph_Based: One of Louvain, Leiden, Greedy, WalkTrap, Spinglass, Leading_Eigen or Edge_Betweenness.}

\item{Graph_Resolution}{If strategy is Graph_Based: Used for Louvain and Leiden. 1 is default. The smaller the value, the larger the clusters will be.}

\item{N_steps}{If strategy is Graph_Based: Number of steps given in the WalkTrap algorithm.}

\item{N_K_centroids}{If strategy is K_Means_Meta_clustering: Number of centroids to perform K means.}

\item{Max_N_neighborhoods_Meta}{If strategy is K_Means_Meta_clustering: Number of maximum neighborhoods that can be identified.}

\item{Consensus_reps_Meta}{If strategy is K_Means_Meta_clustering: Number of iterations to converge.}

\item{Consensus_p_Items_Meta}{If strategy is K_Means_Meta_clustering: Percentage of cells that you desire to sample in each iteration.}

\item{Consensus_Name_Meta}{If strategy is K_Means_Meta_clustering: Name of the folder that is going to be created in order to place the resulting graphs.}

\item{Batch_size}{If strategy is Batch_K_means: Number of cells to be included in each random batch.}

\item{Max_N_neighborhoods_Batch}{If strategy is Batch_K_means: Number of maximum neighborhoods that can be identified.}

\item{N_initiations}{If strategy is Batch_K_means: Number of times the algorithm is going to be tried to find the best clustering result.}

\item{Max_iterations}{If strategy is Batch_K_means: Max number of iterations in each try.}

\item{Quality_metric}{If strategy is GMM:T he quality measure used to test the number of clusters ("AIC" or "BIC").}

\item{Max_N_neighborhoods_GMM}{If strategy is GMM: Number of maximum neighborhoods that can be identified.}

\item{Max_iterations_km}{If strategy is GMM: Number of max iterations in the K means clustering performed.}

\item{Max_iterations_em}{If strategy is GMM: Number of max iterations in the Expectation Maximization algorithm.}

\item{GMM_Distance}{If strategy is GMM: Distance metric used in the model ("eucl_dist" or "maha_dist").}

\item{Samples_CLARA}{If strategy is CLARA_clustering: Number of samples the CLARA algorithm is going to use to be calculated.}

\item{Sample_per_CLARA}{If strategy is CLARA_clustering: Percentage (from 0 to 1) of the total cells that are going to be allocated to each sample.}

\item{Max_N_neighborhoods_CLARA}{If strategy is CLARA_clustering: Number of maximum neighborhoods that can be identified.}

\item{Distance_CLARA}{If strategy is CLARA_clustering: Distance metric used in the model (euclidean, manhattan, chebyshev, canberra, braycurtis, pearson_correlation, simple_matching_coefficient, minkowski, hamming, jaccard_coefficient, Rao_coefficient, mahalanobis, cosine)}

\item{N_cores}{If strategy is CLARA_clustering: Number of cores to parallelize your computation}
}
\value{
Returns a tibble with cell features and a column named 'Neighborhood_assignment' containing cell neighborhoods.
If dimension reduction has been performed returns a list with the cell feature dataset as above and a tibble containing dimension reduction coordinates.
}
\description{
The function identifies cell neighborhoods based on message-passed cell obtained using the \code{\link[=UTAG_message_passing]{UTAG_message_passing()}} function.
}
\details{
De-noising process does not remove cells from the final output. It rather assigns noise cells to a single phenotype. Otsu thresholding and DBSCAN based denoising are based on EBImage::otsu and dbscan::dbscan functions, respectively.

Dimension reduction can be performed using PCA (svd::propack.svd function), t-SNE (snifter::fitsne function) and UMAP (uwot::tumap function). For t-SNE and UMAP a model can be build using a subset of data and then predicting coordinates for all the cells. This can be more computationally efficient.

Consensus clustering is performed using the ConsensusClusterPlus::ConsensusClusterPlus function.

Self Organizing Maps clustering is performed using the FlowSOM::FlowSOM function.

For graph based clustering Nearest neighbors graphs are built using bluster::makeSNNGraph and clustered using functions included in the igraph package.

K_Means_Meta_clustering first summarizes cell feature matrix observations using K means algorithm and the performs Consensus Clustering. Afterwards results are generalized to all cells.

Batch K-means, Gaussian Mixture Models and Clustering Large Applications are all based on the ClusterR package.
}
\examples{
\dontrun{
Message_passed_cells <-
UTAG_message_passing(
    DATA = CSM_Arrangedcellfeaturedata_test,

    Neighbor_strategy = "Distance",
    Message_strategy = "Sum",
    Max_dist_allowed = 50,
    Weighting_Strategy = "Proximity",

    N_cores = 1
)

UTAG_Neighborhood_identifier(
   DATA = Message_passed_cells,
   Strategy = "Batch_K_means",
   Min_Neighbors = 5,

   Apply_Denoise = TRUE,
   Denoising = "Otsu",

   Perform_Dimension_reduction = TRUE,
   Dimension_reduction = "UMAP",
   Dimension_reduction_prop = 1,
   Cluster_on_Reduced = TRUE,

   Batch_size = 100,
   Max_N_neighborhoods_Batch = 10,
   N_initiations = 10,
   Max_iterations = 10
)
}

}
\seealso{
\code{\link[=UTAG_message_passing]{UTAG_message_passing()}}, \code{\link[=DATA_neighborhoods_renamer]{DATA_neighborhoods_renamer()}}, \code{\link[=Neighborhood_Quantifier]{Neighborhood_Quantifier()}}, \code{\link[=Neighborhood_voting_function]{Neighborhood_voting_function()}}, \code{\link[=Tiled_neighborhoods_graphicator]{Tiled_neighborhoods_graphicator()}}
}
